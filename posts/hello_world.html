<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js"></script>

<h3>Hello!</h3>
This is my first post. I started building a blog with Django but I felt it was a bit to much and I don't feel like paying for servers etc. <br>
So a I figure why not make a static site, put it up on github and make a quick html-generator with python that I can run from the terminal. <br>
I guess there is a lot of static-site generators out there, but I just wanted something quick and simple.<br><br>

I'll get back to web dev in the future. but for now, this will be ok!
<i class="far fa-calendar-check"></i><br>
<br><br>
<h3>Going From Hardware to Software</h3><br>
I'm taking some courses in C and bulding a 'virtual computer' from scratch! (<a href='https://www.nand2tetris.org/'>Nand2Tetris</a> & <a href='https://www.coursera.org/specializations/c-programming'>C-programming</a>)<br>
I usually only code in Python and some C# which is very high level.
This will hopefully help me understand a bit more what Im actually doing when Im writing and running code. <i class="far fa-grin-beam-sweat"></i><br>
Why Im writing it here is for me to kind of explain all the <i>(sometimes difficult)</i> concepts to myself <i>(mostly)</i> with my own words.<br>
<br>
A computer is built up by a huuge amount of transistors. the most common logic gates are the Nand, And, Or and Not.<br>
It's really insane that these basic components when combined can built something so advanced and powerful.<br>
And after layer and layer of abstractions we can have something like Photoshop *pooof*
<br><br>
<img src="https://qph.fs.quoracdn.net/main-qimg-3365ebf23427d9d0a5217c5bc4d7ade3-c" alt=""><br><br>
Here are some gates that we built in the course with the help of boolean algebra and truth tables:<br>
And, And16, DMux, DMux4Way, DMux8Way, Mux, Mux4Way16, Mux8Way16,Mux16, Not, Xor..

<br>
<pre><code class="language-js">// Commutative Laws
  (x AND y)=(y AND x)
  (x OR y)=(y Or x)

  //Associative Laws
  (x AND (y AND z))=((x AND y) AND z)
  (x OR (y OR z))=((x OR y) OR z)

  //Distributive Laws
  (x AND (y OR z)) =(x AND y) OR (x AND z)
  (x OR (y OR z))=(x OR y) AND (x OR z)

  //De Morgan Laws
  NOT(x AND y)=NOT(x) OR NOT(y)
  NOT(x OR y)=NOT(x) AND NOT(y)
</code></pre>
<br>Example of an Multiplexer to a Demultiplexer<br>
This can be used to pack multiple streams of 1 and 0s into one stream and then pack it up again into multiple streams.<br>
<img src="https://upload.wikimedia.org/wikipedia/commons/e/e0/Telephony_multiplexer_system.gif" alt="">

<br><br><br>Here is a DMux in HDL (Hardware Dynamic Language) and its truth table.
<pre><code class="language-js">CHIP DMux {
      IN in, sel;
      OUT a, b;

      PARTS:
      Not(in=sel, out=nots);
      And(a=in, b=nots, out=a);
      And(a=in, b=sel, out=b);
  }

//|  in   |  sel  |   a   |   b   |
//|   0   |   0   |   0   |   0   |
//|   0   |   1   |   0   |   0   |
//|   1   |   0   |   1   |   0   |
//|   1   |   1   |   0   |   1   |

</code></pre><br><br>
<h4><i class="fas fa-calculator"></i> Counting with binary</h4>
<br>
When counting in binary we count with the base of 2 instead of 10. <br>
Converting isn't that hard, say the number 87, which is 64+16+4+2+1.
We can just find the highest number that goes into 87 in this case it's 64 and
then work our way down until we get the sum 87.
<pre><code class="language-js">
//87 is 64+16+4+2+1
1 | 2 | 4 | 8 | 16 | 32 | 64 | 128
^ | ^ | ^ | x | ^  | x  | ^  | x
//Now we really just have to count and add 1 and 0

1010111 binary = 87 decimal

//1(64)+ 0(0) + 1(16) + 0(0) + 1(4) + 1(2) + 1(1)... 64+16+4+2+1=87

</code></pre><br><br>

Adding with Binary is also quite simple.
<br>
<pre><code class="language-js">
//21 + 21 = 42
// we just move the carrying bit
        1   1   1
    0 0 0 1 0 1 0 1
  +
    0 0 0 1 0 1 0 1
    _______________
    0 0 1 0 1 0 1 0



//Example of overflow (8 bit)

        1 1 1
    0 0 0 1 0 1 0 1
  +
    0 1 0 1 1 1 0 0
    _______________
(1) 0 1 1 1 0 0 0 1

/* Pasted from the course:
*here we have a carry that needs to go to the left of the words size.
*So from a mathematical point of view, what it means is that the addition that we're actually doing in our
*hardware is not real integer addition, because we cannot go beyond the numbers that fit inside the word size.
*Instead, what we have is really an addition module 2 to the width of the word size if you look at it mathematically.
*in other words, the answer is correct, but may, except for the case that it may be off by exactly 2
*to the n where n is the word size. If the result was more than 2 to the n,
*the hardware automatically decreases 2 to the n, which is basically the carry that we just threw because there was an overflow.
*
*Most CPUs use a much bigger word size than 8 bits.
*Many PCs have a 64-bit CPU. A 64-bit CPU can handle numbers larger than 18 quintillion
*(18,446,744,073,709,551,615).
*/
</code></pre>

<br><br><br>Here is a HalfAdder and a FullAdder in HDL, it returns a sum and a carry.
<pre><code class="language-js">CHIP HalfAdder {
    IN a, b;    // 1-bit inputs
    OUT sum,    // Right bit of a + b
        carry;  // Left bit of a + b

    PARTS:
    // Put you code here:
    And(a=a, b=b, out=carry);
    Xor(a=a, b=b, out=sum);
}

//|   a   |   b   |  sum  | carry |
//|   0   |   0   |   0   |   0   |
//|   0   |   1   |   1   |   0   |
//|   1   |   0   |   1   |   0   |
//|   1   |   1   |   0   |   1   |

CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:

    HalfAdder(a=a,    b=b, sum=sum1, carry=carry1);
    HalfAdder(a=sum1, b=c, sum=sum,  carry=carry2);

    Or(a=carry1, b=carry2, out=carry);
}

//|   a   |   b   |   c   |  sum  | carry |
//|   0   |   0   |   0   |   0   |   0   |
//|   0   |   0   |   1   |   1   |   0   |
//|   0   |   1   |   0   |   1   |   0   |
//|   0   |   1   |   1   |   0   |   1   |
//|   1   |   0   |   0   |   1   |   0   |
//|   1   |   0   |   1   |   0   |   1   |
//|   1   |   1   |   0   |   0   |   1   |
//|   1   |   1   |   1   |   1   |   1   |
</code></pre><br><br>
However I found negative numbers much trickier..
<a href='https://en.wikipedia.org/wiki/Two%27s_complement'>2's Complement representation</a>
<pre><code class="language-js">
  //-2 + - 3 is in 2's compliment 14 + 13

  -2      14    1110
  +      +     +
  -3      13    1101
  ___    ___   _____
  -5      11    (1)1011

  11011 = 27  (14+13)
  without the carrying bit: 1011=11 which is 11s the 2's compliment -5!

  Here is a trick to find the 2's complement:
   1111
  -
   1011  //11
  +   1
  ______
   0101 //5

</code></pre><br><br>

We didn't make any chip for multiplication or division, it will be done in
software. This is how binary multiplication works:
<pre><code class="language-js">
     1011   //(this is 11 in binary)
   x 1110   //(this is 14 in binary)
   ======
     0000   //(this is 1011 x 0)
    1011    //(this is 1011 x 1, shifted one position to the left)
   1011     //(this is 1011 x 1, shifted two positions to the left)
+ 1011      //(this is 1011 x 1, shifted three positions to the left)
=========
10011010   //(this is 154 in binary)
</code></pre><br><br>
.. and here is a yt-video explaining division<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ubCCemtuZH8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<br><br><br>
<h4><i class="fas fa-microchip"></i> Memory</h4><br>
We don't just want to run one calculation but multiple calculations after each other.
Todo this we break up the physical time into intervals, time units, with a clock. <br>
The physical time between the time units is enough to read the voltage properly.
<br><br>
<p><b>Combinatorial:</b> out[t] = function(int[t])</p>
<p><b>Sequential:</b> out[t] = function(in[t-1])</p>

<br>
<ul>
<li>Combinational logic uses only the present inputs to determine the
output while sequential logic uses both present inputs as well as
previous outputs to determine the current input.</li>
<br>
<li>Combinational logic is used to implement basic Boolean
  operations while sequential logic is used to create memory elements.</li>
<br>
<li>Sequential logic uses the feedbacks from the output
to inputs while combinational logic does not require feedbacks.</li>
</ul>
<br>
<b>Flip Flops</b><br>
This is a flip-flop constructed from cross-coupled NOR gates. (thx wikipedia)<br><br>
<img src="https://upload.wikimedia.org/wikipedia/commons/c/c6/R-S_mk2.gif" alt="">
<br><br>The flip-flop kind of "delays" the out value one time unit.
<b>out[t] = in[t-1]</b><br><br>
From a flip Flop we can create a 1-Bit register..
<pre><code class="language-js">if load(t-1) then out(t)=in(t-1)
else out(t)=out(t-1)
</code></pre><br><br>
This can be created with a Multiplexer and a DFF (data flip-flop)

<pre><code class="language-js">CHIP Bit {
    IN  in, load;
    OUT out;

    PARTS:
        Mux(a = loopIn, b = in, sel = load, out = outMux);
        DFF(in = outMux, out = loopIn, out = out);
}
</code></pre><br>
and from this we can now build a PC (program counter) a simple register, a Ram8 and a Ram64 etc..<br>
(Part of <a href="https://www.nand2tetris.org/project03">Project03</a>)<br><br>

The RAM have multiple registers and each register have a unique adress.<br>
The width of the adress is determined by the log base 2 of the numer of registers. <br><br>
<i>Example:<br>  RAM8 holding 8 registers needs a 3-bit adress. log2(8)=3<br>
 000 refering to register 0 and 111 refering to register 7, and then all the registers inbetween</i>
<br><br>
This means bigger memory longer adresses. Accessing memory location is expensive and getting the memory
contents into the CPU takes time. The solution to this is a <b>Memory Heirarchy!</b>
<br><br>
<img src="https://upload.wikimedia.org/wikipedia/commons/0/0c/ComputerMemoryHierarchy.svg" alt="" height=50% width=50%>
<br>
The farther away from the arithmetic unit we get the bigger grows the memory.<br>
CPUs usually contain a few, small registers.<br>
Their number and functions are a central part of the machine language.
<br><br><br>
<h4><i class="fas fa-language"></i> Machine & Assembly Language</h4><br>
The Machine only speaks 0 and 1s and a machine language program
is just a serie of instructions written with these two numbers.<br>
An example of an instruction for a 16-bit machine could be <i>"010001000110010"</i>,
to know what it does we need to know the hardwares instruction set.<br>
Diffrent parts of the 16-bit 'string' can mean different things, for example the first four bits
may be a kind of CPU operation and the other bits could tell which registers to do the
operations on.
These 0 and 1 instructions are very hard to read so to make it easier to write these instructions
we can use 'symbolic mnemonics'. Which can make for example the "010001000110010" binary instruction
into something more readable like <i>'ADD R3 R2'</i>. This symbolic notation is called the <b>Assambly language.</b>
We can write the program in Assambly and then convert it to binary, hopefully with a <br>
text processing program.. that program is called an <b>Assambler</b> <i class="far fa-grin-wink"></i><br><br>



<pre><code class="language-js">//add Register 3 to register 2
0100010 | 0011 | 0010
ADD        R3     R2
</code></pre><br><br>

There is a lot of different assambly languages, all with different syntax.
However, all the languages supports a set of similar generic commands.<br><br>
There is two categories of Memory accessing: First, arithmetic and logical.
Second the load and store commands, designed to move data between registers and memory.
The load and store commands may use several types of <b>addressing modes</b>.<br><br>
<b>Direct Addressing:</b><br>
Here we load memory directly with a specific memory adress
<pre><code class="language-js">LOAD R1, 18 // R1<---Memory[18]
</code></pre><br><br>
<b>Immediate Addressing:</b><br>
Here we Load a constant instead of an adress into memory
<pre><code class="language-js">LOADI R1, 18 // R1<---Memory[18]
</code></pre><br><br>
<b>Indirect Addressing:</b><br>
Here we specify a memory location that holds the required adress.
<pre><code class="language-js">LOAD* R2,R1 // R2<---Memory[R1]
</code></pre><br>
The indirect adressing is used to deal with pointers.
a simple example: if we create an array in a high level language,
the compiler will allocate some memory and point to the first adress in that memory.
When we want to access a specific n-index of the array
we can just add that n to the first adress in the array. <br>
For example: x = somearray[i] this in C could also be written like x=*(somearray+i).

<pre><code class="language-js">// Translation of x=*(somearray+i):
ADD R1,somearray,i // R1<---somearray+i
LOAD* R2,R1 // R2<---Memory[R1]
STR R2,x // x<---R2
</code></pre><br><br>

<b><i class="fas fa-gamepad"></i> Flow Control</b><br>
Most of the time programs run in a linear fashion but sometimes we want to do
a thing called <b>branching</b>. The branching serves several purposes,
<b>repitition</b> (loop), <b>conditional execution</b> (if-then) and
<b>subroutine calling</b> (jump to some other code segment).
<br>
<pre><code class="language-js">// A while loop in high level code:
while (R1>=0) {
code segment 1
}
code segment 2

// in low level code
// Typical translation:
beginWhile:
JNG R1,endWhile // If R1<0 goto endWhile
// Translation of code segment 1 comes here
JMP beginWhile // Goto beginWhile
endWhile:
// Translation of code segment 2 comes here
</code></pre><br><br>

<b>The Von Neumann Platform</b><br>
In the course we built a von Neumann computer called "hack".
It's a 16 bit machine, with a CPU, two memory modules serving
as instruction memory and data memory and two memory-mapped I/O Divices.
(keyboard and screen)<br>
There is two 16-bit registers called D and A. D is used solely to store values
while A is used for both values and addresses.<br>
It's not enough space to pack both the memory address and the operation commands
into one 16bits instruction, therefore the syntax of the hack lang instructs on
an implicit memory location labeled "M".
So what M refers to is always the current value of A register.
If we want to use do the operation D = Mem[101]-1 we first have to set the current
register of A to 101 and then say D=M-1.The A register is also used to give direct access to instruction memory.
Therfore it's the samething with jumping. We first have to set the A register
and then say which command we want to do. For Example: if we want "goto 20",
we first have to set A=20, and then we can do the goto command.<br><br>
The Hack Language have two generic instructions A-instruction (adress)
and a C-instruction (compute).
<br><br>
C language<br>
<pre><code class="language-js">// Adds 1+...+100.
int i = 1;
int sum = 0;
While (i <= 100){
sum += i;
i++;
}
</code></pre><br>
The course Im doings "Hack" machine language, with me over explaining every move <br>
to try to understand it all.
<pre><code class="language-js">// Adds 1+...+100.
@i // Set the current register to some mem. i
M=1 // Sets that 'i' register to store value 1
@sum // Sets the register to some mem. sum
M=0 // sum=0
(LOOP) // start loop
@i // set register to i
D=M // store whats in i into D
@100 // store 100 in the A register
D=D-A // take whats in the D register (i) - 1 set D register again
@END // Set the register to the END instruction
D;JGT // If (i-100)>0 goto END
@i // set the current register to i
D=M // set D to the current register "i"
@sum // set the current register to sum
M=D+M // sum=i+sum
@i // set current to i
M=M+1 // i=i+1
@LOOP // set register to instruction LOOP
0;JMP // Goto LOOP
(END) // end loop
@END  // set current register to END to create infinte loop
0;JMP // Infinite loop
</code></pre>
<a href="https://docs.wixstatic.com/ugd/44046b_7ef1c00a714c46768f08c459a6cab45a.pdf">From the awesome course PDF</a>
<br><br>
The C-instruction gets most of the things done on the hack platform.
The instruction includes: A. what to compute, B. where to store it afterwards
and C. what todo next!<br>
<pre><code class="language-js">//dest=comp;jump
A    B             C               D          J
1 | 1 1 | a c1 c2 c3 c4 c5 c6 | d1 d2 d3 | j1 j2 j3

A = op-code
B = rests
C = comp
D = dest
J = jump

//increment the value of Memory[7] by 1
0000 0000 0000 0111 // @7 (A-Instruction)
1111 1101 1101 1000 // MD=M+1 (C-Instruction)

/*
*when a = 1
*and c1->c6= 1 1 0 1 1 1
*the comp mnemonics are M+1
* and d->d3= 0 1 1
* the destination mnemonics are MD (Memory[A] and D register)
*/
</code></pre><br>
The jump field of the C-instruction
<pre><code class="language-js">0 0 0 | null | No jump
0 0 1 | JGT  | If out > 0 jump
0 1 0 | JEQ  | If out ¼ 0 jump
0 1 1 | JGE  | If out b 0 jump
1 0 0 | JLT  | If out < 0 jump
1 0 1 | JNE  | If out 0 0 jump
1 1 0 | JLE  | If out a 0 jump
1 1 1 | JMP  | Jump
</code></pre><br><br>

<b><i class="fas fa-flag"></i> Predefined Symbols in the assambly program</b><br>
A special subset of RAM adresses can be reffered by:<br><br>
<ul>
  <li><b>Virtual Registers:</b>
    <i> <b>R0</b> to <b>R15</b> referes to RAM adresses 0 to 15..</i></li><br>
  <li><b>Predefined Pointers:</b>
    <i> <b>SP</b>, <b>LCL</b>, <b>ARG</b>, <b>THIS</b> and <b>THAT</b> refer to RAM adresses 0 to 4</i></li><br>
  <li><b>I/O pointers:</b> <i><b>SCREEN</b> and <b>KBD</b> refer to RAM
  addresses 16384 (0x4000) and 24576 (0x6000)</i></li><br>
  <li><b>Label Symbols:</b> <i>are declared by the pseudo-command ‘‘(SOMENAME)’’ A label can be
      defined only once and can be used anywhere in the assembly program, even before the line in which it is defined.</i></li><br>
  <li><b>Variable symbols:</b> <i>Any user defined symbol will be treated as an
  variable starting at RAM adress 16 (0x0010)</i></li>
</ul><br><br>


<br><br>
<h4><i class="far fa-keyboard"></i> I/O </h4>

<b>Screen memory map</b><br>
The screen memory map is a designated memory area dedicated to manage the display unit.
The display is continously refreshed from the memory map.<br>
The Display Unit in the course is using a display 256 by 512, b/w.
The screen’s contents are represented by an 8K memory
map that starts at RAM address 16384 (0x4000)
<ul>
    <li>word=Screen[32*row + col/16]</li>
    <li>word = RAM[16384 + 32*row + col/16]</li>
    <li>2 set the (col%16)th bit of word 0 or 1</li>
</ul>

<i>Here's an example:<br>change the bit in row 4 column 55. which address should you retrieve,
and which bit should you change?</i><br>
word = Screen[32*4 + 55/16] (integer)<br>
word = Screen[128 + 3]<br>
word = Screen[131]<br>
7 = 55%16 (col%16)th bit<br>
<br>
Answer: Screen[131], 7th bit!<br>
<br>
<pre><code class="language-js">// Draw a single black dot at the screen's top left corner:
@SCREEN // Set the A register to point to the memory
// word that is mapped to the 16 left-most
// pixels of the top row of the screen.
M=1 // Blacken the left-most pixel.
</code></pre><br><br>

<b>Keyboard Memory map</b><br>
The Hack computer interfaces with the physical keyboard via a
single-word memory map located in RAM address 24576 (0x6000).
To represent the keyboard we don't need more then 16bit.<br>
When a key is pressed on the key's "scan code" appears
in the <i>keyboard memory map</i><br>
<i>example: if 'k' is pressed the scan-code of 'k' is 75, which is
going to look like this '0000000001001011' in the keyboard chip.<br>
If the keyboard is not used they keyboard chip is all zero.</i><br>
<br>


<br><br>
<br><br>
Von Neumann architecture<br>
<img src="https://upload.wikimedia.org/wikipedia/commons/6/68/Computer_system_bus.svg" alt="" height=40% width=40%><br>
<h4><i class="fas fa-recycle"></i> The Fetch-execute cycle</h4>
The basic operation of a computer is called the ‘fetch-execute’ cycle. <br>
The computer fetches the instruction from its memory and then executes it.
This is done repeatedly from when the computer is booted up to when it is shut down.<br><br>

<br><br><br>
Some random cool links I found while studying this etc.<br>
<i class="fas fa-rocket"></i> <a href="https://github.com/chrislgarry/Apollo-11/blob/master/Comanche055/AGC_BLOCK_TWO_SELF-CHECK.agc">Assambler code form Apollo-II</a><br>
<i class="fas fa-paperclip"></i> <a href="https://www.bbc.com/bitesize/guides/zws8d2p/revision/1">These BBC pages are really nice, simple explanations!</a><br>
<i class="fas fa-bolt"></i> <a href="https://www.youtube.com/watch?v=HyznrdDSSGM&list=PLowKtXNTBypGqImE405J2565dvjafglHU&index=1">8bit computer tutorial (WOW! Need to learn more about electronics!)</a> and <a href="https://eater.net/8bit/clock">heres the blog!</a><br>
