<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js"></script>

<h3>Hello!</h3>
This is my first post. I started building a blog with Django but I felt it was a bit to much and I don't feel like paying for servers etc. <br>
So a I figure why not make a static site, put it up on github and make a quick html-generator with python that I can run from the terminal. <br>
I guess there is a lot of static-site generators out there, but I just wanted something quick and simple.<br><br>

I'll get back to web dev in the future. but for now, this will be ok!
<i class="far fa-calendar-check"></i><br>
<br><br>
<h3>Going From Hardware to Software</h3><br>
I'm taking some courses in C and HDL etc. (<a href='https://www.nand2tetris.org/'>Nand2Tetris</a> & <a href='https://www.coursera.org/specializations/c-programming'>C-programming</a>)
I usually only code in Python and some C# which is very high level.<br>
This will hopefully help me understand a bit more what Im actually doing when Im writing and running code. <i class="far fa-grin-beam-sweat"></i><br>
Why Im writing it here is for me to kind of explain all the <i>(sometimes difficult)</i> concepts to myself <i>(mostly)</i> with my own words.<br>
<br>
A computer is built up by a huuge amount of transistors. the most common logic gates are the Nand, And, Or and Not.<br>
It's really insane that these basic components when combined can built something so advanced and powerful.<br>
And after layer and layer of abstractions we can have something like Photoshop *pooof*
<br><br>
<img src="https://qph.fs.quoracdn.net/main-qimg-3365ebf23427d9d0a5217c5bc4d7ade3-c" alt=""><br><br>
Here are some gates that we built in the course with the help of boolean algebra and truth tables:<br>
And, And16, DMux, DMux4Way, DMux8Way, Mux, Mux4Way16, Mux8Way16,Mux16, Not, Xor..

<br>
<pre><code class="language-js">// Commutative Laws
  (x AND y)=(y AND x)
  (x OR y)=(y Or x)

  //Associative Laws
  (x AND (y AND z))=((x AND y) AND z)
  (x OR (y OR z))=((x OR y) OR z)

  //Distributive Laws
  (x AND (y OR z)) =(x AND y) OR (x AND z)
  (x OR (y OR z))=(x OR y) AND (x OR z)

  //De Morgan Laws
  NOT(x AND y)=NOT(x) OR NOT(y)
  NOT(x OR y)=NOT(x) AND NOT(y)
</code></pre>
<br>Example of an Multiplexer to a Demultiplexer<br>
This can be used to pack multiple streams of 1 and 0s into one stream and then pack it up again into multiple streams.<br>
<img src="https://upload.wikimedia.org/wikipedia/commons/e/e0/Telephony_multiplexer_system.gif" alt="">

<br><br><br>Here is a DMux in HDL (Hardware Dynamic Language) and its truth table.
<pre><code class="language-js">CHIP DMux {
      IN in, sel;
      OUT a, b;

      PARTS:
      Not(in=sel, out=nots);
      And(a=in, b=nots, out=a);
      And(a=in, b=sel, out=b);
  }

//|  in   |  sel  |   a   |   b   |
//|   0   |   0   |   0   |   0   |
//|   0   |   1   |   0   |   0   |
//|   1   |   0   |   1   |   0   |
//|   1   |   1   |   0   |   1   |

</code></pre><br><br>
<h4><i class="fas fa-calculator"></i> Counting with binary</h4>
<br>
When counting in binary we count with the base of 2 instead of 10. <br>
Converting isn't that hard, say the number 87, which is 64+16+4+2+1.
We can just find the highest number that goes into 87 in this case it's 64 and
then work our way down until we get the sum 87.
<pre><code class="language-js">
//87 is 64+16+4+2+1
1 | 2 | 4 | 8 | 16 | 32 | 64 | 128
^ | ^ | ^ | x | ^  | x  | ^  | x
//Now we really just have to count and add 1 and 0

1010111 binary = 87 decimal

//1(64)+ 0(0) + 1(16) + 0(0) + 1(4) + 1(2) + 1(1)... 64+16+4+2+1=87

</code></pre><br><br>

Adding with Binary is also quite simple.
<br>
<pre><code class="language-js">
//21 + 21 = 42
// we just move the carrying bit
        1   1   1
    0 0 0 1 0 1 0 1
  +
    0 0 0 1 0 1 0 1
    _______________
    0 0 1 0 1 0 1 0



//Example of overflow (8 bit)

        1 1 1
    0 0 0 1 0 1 0 1
  +
    0 1 0 1 1 1 0 0
    _______________
(1) 0 1 1 1 0 0 0 1

/* Pasted from the course:
*here we have a carry that needs to go to the left of the words size.
*So from a mathematical point of view, what it means is that the addition that we're actually doing in our
*hardware is not real integer addition, because we cannot go beyond the numbers that fit inside the word size.
*Instead, what we have is really an addition module 2 to the width of the word size if you look at it mathematically.
*in other words, the answer is correct, but may, except for the case that it may be off by exactly 2
*to the n where n is the word size. If the result was more than 2 to the n,
*the hardware automatically decreases 2 to the n, which is basically the carry that we just threw because there was an overflow.
*
*Most CPUs use a much bigger word size than 8 bits.
*Many PCs have a 64-bit CPU. A 64-bit CPU can handle numbers larger than 18 quintillion
*(18,446,744,073,709,551,615).
*/
</code></pre>

<br><br><br>Here is a HalfAdder and a FullAdder in HDL, it returns a sum and a carry.
<pre><code class="language-js">CHIP HalfAdder {
    IN a, b;    // 1-bit inputs
    OUT sum,    // Right bit of a + b
        carry;  // Left bit of a + b

    PARTS:
    // Put you code here:
    And(a=a, b=b, out=carry);
    Xor(a=a, b=b, out=sum);
}

//|   a   |   b   |  sum  | carry |
//|   0   |   0   |   0   |   0   |
//|   0   |   1   |   1   |   0   |
//|   1   |   0   |   1   |   0   |
//|   1   |   1   |   0   |   1   |

CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:

    HalfAdder(a=a,    b=b, sum=sum1, carry=carry1);
    HalfAdder(a=sum1, b=c, sum=sum,  carry=carry2);

    Or(a=carry1, b=carry2, out=carry);
}

//|   a   |   b   |   c   |  sum  | carry |
//|   0   |   0   |   0   |   0   |   0   |
//|   0   |   0   |   1   |   1   |   0   |
//|   0   |   1   |   0   |   1   |   0   |
//|   0   |   1   |   1   |   0   |   1   |
//|   1   |   0   |   0   |   1   |   0   |
//|   1   |   0   |   1   |   0   |   1   |
//|   1   |   1   |   0   |   0   |   1   |
//|   1   |   1   |   1   |   1   |   1   |
</code></pre><br><br>
However I found negative numbers much trickier..
<a href='https://en.wikipedia.org/wiki/Two%27s_complement'>2's Complement representation</a>
<pre><code class="language-js">
  //-2 + - 3 is in 2's compliment 14 + 13

  -2      14    1110
  +      +     +
  -3      13    1101
  ___    ___   _____
  -5      11    (1)1011

  11011 = 27  (14+13)
  without the carrying bit: 1011=11 which is 11s the 2's compliment -5!

  Here is a trick to find the 2's complement:
   1111
  -
   1011  //11
  +   1
  ______
   0101 //5

</code></pre><br><br>

We didn't make any chip for multiplication or division, it will be done in
software. This is how binary multiplication works:
<pre><code class="language-js">
     1011   //(this is 11 in binary)
   x 1110   //(this is 14 in binary)
   ======
     0000   //(this is 1011 x 0)
    1011    //(this is 1011 x 1, shifted one position to the left)
   1011     //(this is 1011 x 1, shifted two positions to the left)
+ 1011      //(this is 1011 x 1, shifted three positions to the left)
=========
10011010   //(this is 154 in binary)
</code></pre><br><br>
.. and here is a yt-video explaining division<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ubCCemtuZH8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<br><br><br>
<h4><i class="fas fa-microchip"></i> Memory</h4><br>
We don't just want to run one calculation but multiple calculations after each other.
Todo this we break up the physical time into intervals, time units, with a clock. <br>
The physical time between the time units is enough to read the voltage properly.
<br><br>
<p><b>Combinatorial:</b> out[t] = function(int[t])</p>
<p><b>Sequential:</b> out[t] = function(in[t-1])</p>

<br>
<ul>
<li>Combinational logic uses only the present inputs to determine the
output while sequential logic uses both present inputs as well as
previous outputs to determine the current input.</li>
<br>
<li>Combinational logic is used to implement basic Boolean
  operations while sequential logic is used to create memory elements.</li>
<br>
<li>Sequential logic uses the feedbacks from the output
to inputs while combinational logic does not require feedbacks.</li>
</ul>
<br>
<b>Flip Flops</b><br>
This is a flip-flop constructed from cross-coupled NOR gates. (thx wikipedia)<br><br>
<img src="https://upload.wikimedia.org/wikipedia/commons/c/c6/R-S_mk2.gif" alt="">
<br><br>The flip-flop kind of "delays" the out value one time unit.
<b>out[t] = in[t-1]</b><br><br>
From a flip Flop we can create a 1-Bit register..
<pre><code class="language-js">if load(t-1) then out(t)=in(t-1)
else out(t)=out(t-1)
</code></pre><br><br>
This can be created with a Multiplexer and a DFF (data flip-flop)

<pre><code class="language-js">CHIP Bit {
    IN  in, load;
    OUT out;

    PARTS:
        Mux(a = loopIn, b = in, sel = load, out = outMux);
        DFF(in = outMux, out = loopIn, out = out);
}
</code></pre><br>
and from this we can now build a PC (program counter) a simple register, a Ram8 and a Ram64 etc..<br>
(Part of <a href="https://www.nand2tetris.org/project03">Project03</a>)<br><br>

The RAM have multiple registers and each register have a unique adress.<br>
The width of the adress is determined by the log base 2 of the numer of registers. <br><br>
<i>Example:<br>  RAM8 holding 8 registers needs a 3-bit adress. log2(8)=3<br>
 000 refering to register 0 and 111 refering to register 7, and then all the registers inbetween</i>
<br><br>
This means bigger memory longer adresses. Accessing memory location is expensive and getting the memory
contents into the CPU takes time. The solution to this is a <b>Memory Heirarchy!</b>
<br><br>
<img src="https://upload.wikimedia.org/wikipedia/commons/0/0c/ComputerMemoryHierarchy.svg" alt="" height=50% width=50%>
<br>
The farther away from the arithmetic unit we get the bigger grows the memory.<br>
CPUs usually contain a few, small registers.<br>
Their number and functions are a central part of the machine language.
<br><br><br>
<h4><i class="fas fa-language"></i> Machine & Assembly Language</h4><br>
The Machine only speaks 0 and 1s and a machine language program
is just a serie of instructions written with these two numbers.<br>
An example of an instruction for a 16-bit machine could be <i>"010001000110010"</i>,
to know what it does we need to know the hardwares instruction set.<br>
Diffrent parts of the 16-bit 'string' can mean different things, for example the first four bits
may be a kind of CPU operation and the other bits could tell on which registers to do the
operations on.
These 0 and 1 instructions are very hard to read so to make it easier to write these instructions
we can use 'symbolic mnemonics'. Which can make for example the "010001000110010" binary instruction
into something more readable like <i>'ADD R3 R2'</i>. This symbolic notation is called the <b>Assambly language.</b>
We can write the program in Assambly and then convert it to binary, hopefully with a <br>
text processing program.. that program is called an <b>Assambler</b> <i class="far fa-grin-wink"></i><br><br>



<pre><code class="language-js">//add Register 3 to register 2
0100010 | 0011 | 0010
ADD        R3     R2
</code></pre><br><br>

There is a lot of different assambly languages, all with different syntax.
However, all the languages supports a set of similar generic commands.<br>

<br><br>
C language<br>
<pre><code class="language-js">// Adds 1+...+100.
int i = 1;
int sum = 0;
While (i <= 100){
sum += i;
i++;
}
</code></pre><br><br>
The course Im doings "Hack" machine language
<pre><code class="language-js">// Adds 1+...+100.
@i // i refers to some mem. location.
M=1 // i=1
@sum // sum refers to some mem. location.
M=0 // sum=0
(LOOP)
@i
D=M // D=i
@100
D=D-A // D=i-100
@END
D;JGT // If (i-100)>0 goto END
@i
D=M // D=i
@sum
M=D+M // sum=sum+i
@i
M=M+1 // i=i+1
@LOOP
0;JMP // Goto LOOP
(END)
@END
0;JMP // Infinite loop
</code></pre>
<a href="https://docs.wixstatic.com/ugd/44046b_7ef1c00a714c46768f08c459a6cab45a.pdf">From the awesome course PDF</a>
<br><br>
<b>Flow Control</b><br>
All the instructions on the CPU are executed in sequence, cascading from top to bottom.<br>
If we run out of instructions the program counter will just continue, this can lead to some
random errors. To prevent this we end all instructions with an infinity loop.<br>
To make loops or a branch (if/else) we can do a jump.

In the course we built a 16-bit machine. it consists of:
<br>- Data Memory (Ram): a sequence of 16 bit registers<br>
- Instruction Memory (Rom): also a seq of 16bit register<br>
- Central Processing Unit (CPU): performs the 16-bits instructions<br>
- Instruction bus / data bus / adress buses<br><br>

Two ways of express the same semantics:<br>
<pre><code class="language-js">//Symbolic
@17
D+1;JLE

//Binary
0000000000010001
1110011111000110
</code></pre>

<br><br>

the machine language in the course Im taking recognizes three registers:<br>
D holds a 16bit value<br>
A holds a 16bit value<br>
M represents the 16-bit ram register addressed by A<br>
<br>
<pre><code class="language-js">//Syntax
@value
//where value is either a non-negative decimal constant or
//a symbol referring to such a constant
//Semantix
//Sets the A register to 'value'
//Side Effect: RAM[A] becomes the selected RAM register
//example
@21
// sets the A register to 21
// RAM[21] becomes the selected RAM register

// set Ram[100] to -1
@100 // A = 100  (a for adressing)
M=-1 // RAM[100]=-1
</code></pre>
<br>
<pre><code class="language-js">//The C-instruction
  dest = comp ; jump //both dest and jump are optional
</code></pre>
<br>
<pre><code class="language-js">//comp =
  0, 1, -1, D, A, !D, !A, -D, -A, D+1, A+1
  D-1, A-1, D+A, D-A, D&A, D|A, M, !M, -M, M+1,
  M-1, D+M, M-D, D&M, M-D, D&M, D|M
</code></pre>
<br>
<pre><code class="language-js">//dest =
  null, M, D, MD, A, AM, AD, AMD  //M refers to RAM[A]
</code></pre>
<br>
<pre><code class="language-js">//jump =
  null, JGT, JEQ, JGE, JLT, JNE, JLE, JMP
</code></pre>
<br>

<pre><code class="language-js">// Set the 0 register to -1
D=-1

// set RAM[300] to the value of the D register minus 1
@300 // A = 300
M = D-1

// if (D-1==0) jump to execute the instruction stored in RAM[56]
@56 // A=56 select adress
D-1;JEQ // if D-1 equal 0 jump to  56

</code></pre><br>

<pre><code class="language-js">
  //Symbolic syntax @Value
  @21
  //Binary syntax 0value
  (0)000000000010101
  // the last zero is sometimes called an op-code
  // "operation code"
</code></pre><br>
<pre><code class="language-js">//Symbolic Syntax
dest = comp; jump

//binary syntax
1 1 1 a c1 c2 c3 c4 c5 c6 d1 d2 d3 j1 j2 j3

  (1)    |   1 1    | a c1 c2 c3 c4 c5 c6 |  d1 d2 d3  | j1 j2 j3
//op-code  not used       comp bits          dest bits   jump bits
</code></pre>

<br><br>
<h4><i class="far fa-keyboard"></i> I/O </h4>


<b>Screen memory map</b><br>
The screen memory map is a designated memory area dedicated to manage the display unit.
The display is continously refreshed from the memory map.<br>
The Display Unit in the course is using a display 256 by 512, b/w.
To change a pixel we need to do a mapping and we can't just change one bit at a
time as all the memory is in 16 bit.
<ul>
    <li>word=Screen[32*row + col/16]</li>
    <li>word = RAM[16384 + 32*row + col/16]</li>
    <li>2 set the (col%16)th bit of word 0 or 1</li>
</ul>

<i>Here's an example:<br>change the bit in row 4 column 55. which address should you retrieve,
and which bit should you change?</i><br>
word = Screen[32*4 + 55/16] (integer)<br>
word = Screen[128 + 3]<br>
word = Screen[131]<br>
7 = 55%16 (col%16)th bit<br>
<br>
Answer: Screen[131], 7th bit!<br>
<br>
<b>Keyboard Memory map</b><br>
To represent the keyboard we don't need more then 16bit.<br>
When a key is pressed on the key's "scan code" appears
in the <i>keyboard memory map</i><br>
<i>example: if 'k' is pressed the scan-code of 'k' is 75, which is
going to look like this '0000000001001011' in the keyboard chip.<br>
If the keyboard is not used they keyboard chip is all zero.</i>
<br><br><br><br>
Von Neumann architecture<br>
<img src="https://upload.wikimedia.org/wikipedia/commons/6/68/Computer_system_bus.svg" alt="" height=40% width=40%><br>
<h4><i class="fas fa-recycle"></i> The Fetch-execute cycle</h4>
The basic operation of a computer is called the ‘fetch-execute’ cycle. <br>
The computer fetches the instruction from its memory and then executes it.
This is done repeatedly from when the computer is booted up to when it is shut down.<br><br>

<br><br><br>
Some random cool links I found while studying this etc.<br>
<i class="fas fa-rocket"></i> <a href="https://github.com/chrislgarry/Apollo-11/blob/master/Comanche055/AGC_BLOCK_TWO_SELF-CHECK.agc">Assambler code form Apollo-II</a><br>
<i class="fas fa-paperclip"></i> <a href="https://www.bbc.com/bitesize/guides/zws8d2p/revision/1">These BBC pages are really nice, simple explanations!</a><br>
<i class="fas fa-bolt"></i> <a href="https://www.youtube.com/watch?v=HyznrdDSSGM&list=PLowKtXNTBypGqImE405J2565dvjafglHU&index=1">8bit computer tutorial (WOW! Need to learn more about electronics!)</a> and <a href="https://eater.net/8bit/clock">heres the blog!</a><br>
