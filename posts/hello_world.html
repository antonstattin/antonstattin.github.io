<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js"></script>

<h3>Hello!</h3>
This is my first post. I started building a blog with Django but I felt it was a bit to much and I don't feel like paying for servers etc. <br>
So a I figure why not make a static site, put it up on github and make a quick html-generator with python that I can run from the terminal. <br>
I guess there is a lot of static-site generators out there, but I just wanted something quick and simple.<br><br>

I'll get back to web dev in the future. but for now, this will be ok!
<i class="far fa-calendar-check"></i><br>
<br><br>
<h3>Going From Hardware to Software</h3><br>
I'm taking some courses in C and HDL etc. (<a href='https://www.nand2tetris.org/'>Nand2Tetris</a> & <a href='https://www.coursera.org/specializations/c-programming'>C-programming</a>)
I usually only code in Python and some C# which is very high level.<br>
This will hopefully help me understand whats going on under the hood!
<br><br>
A computer is built up by a huuge amount of transistors / logic gates. the most common are the Nand, And, Or and Not gates.<br>
It's really insane that these basic components when combined can built something so advanced and powerful.<br><br>
<img src="https://qph.fs.quoracdn.net/main-qimg-3365ebf23427d9d0a5217c5bc4d7ade3-c" alt=""><br><br>
Here are some gates that we built in the course with the help of boolean algebra and truth tables:<br>
And, And16, DMux, DMux4Way, DMux8Way, Mux, Mux4Way16, Mux8Way16,Mux16, Not, Xor..

<br>
<pre><code class="language-js">// Commutative Laws
  (x AND y)=(y AND x)
  (x OR y)=(y Or x)

  //Associative Laws
  (x AND (y AND z))=((x AND y) AND z)
  (x OR (y OR z))=((x OR y) OR z)

  //Distributive Laws
  (x AND (y OR z)) =(x AND y) OR (x AND z)
  (x OR (y OR z))=(x OR y) AND (x OR z)

  //De Morgan Laws
  NOT(x AND y)=NOT(x) OR NOT(y)
  NOT(x OR y)=NOT(x) AND NOT(y)
</code></pre>
<br>Example of an Multiplexer to a Demultiplexer<br>
This can be used to pack multiple streams of 1 and 0s into one stream and then pack it up again into multiple streams.<br>
<img src="https://upload.wikimedia.org/wikipedia/commons/e/e0/Telephony_multiplexer_system.gif" alt="">

<br><br><br>Here is a DMux in HDL (Hardware Dynamic Language) and its truth table.
<pre><code class="language-js">CHIP DMux {
      IN in, sel;
      OUT a, b;

      PARTS:
      Not(in=sel, out=nots);
      And(a=in, b=nots, out=a);
      And(a=in, b=sel, out=b);
  }

//|  in   |  sel  |   a   |   b   |
//|   0   |   0   |   0   |   0   |
//|   0   |   1   |   0   |   0   |
//|   1   |   0   |   1   |   0   |
//|   1   |   1   |   0   |   1   |

</code></pre><br><br>
<h4><i class="fas fa-calculator"></i> Counting with binary</h4>
<br>
When counting in binary we count with the base of 2 instead of 10. <br>
Converting isn't that hard, say the number 87, which is 64+16+4+2+1.
We can just find the highest number that goes into 87 in this case it's 64 and
then work our way down until we get the sum 87.
<pre><code class="language-js">
//87 is 64+16+4+2+1
1 | 2 | 4 | 8 | 16 | 32 | 64 | 128
^ | ^ | ^ | x | ^  | x  | ^  | x
//Now we really just have to count and add 1 and 0

1010111 binary = 87 decimal

//1(64)+ 0(0) + 1(16) + 0(0) + 1(4) + 1(2) + 1(1)... 64+16+4+2+1=87

</code></pre><br><br>

Adding with Binary is also quite simple.
<br>
<pre><code class="language-js">
//21 + 21 = 42
// we just move the carrying bit
        1   1   1
    0 0 0 1 0 1 0 1
  +
    0 0 0 1 0 1 0 1
    _______________
    0 0 1 0 1 0 1 0



//Example of overflow (8 bit)

        1 1 1
    0 0 0 1 0 1 0 1
  +
    0 1 0 1 1 1 0 0
    _______________
(1) 0 1 1 1 0 0 0 1

/*
*here we have a carry that needs to go to the left of the words size.
*So from a mathematical point of view, what it means is that the addition that we're actually doing in our
*hardware is not real integer addition, because we cannot go beyond the numbers that fit inside the word size.
*Instead, what we have is really an addition module 2 to the width of the word size if you look at it mathematically.
*in other words, the answer is correct, but may, except for the case that it may be off by exactly 2
*to the n where n is the word size. If the result was more than 2 to the n,
*the hardware automatically decreases 2 to the n, which is basically the carry that we just threw because there was an overflow.
*
*Most CPUs use a much bigger word size than 8 bits.
*Many PCs have a 64-bit CPU. A 64-bit CPU can handle numbers larger than 18 quintillion
*(18,446,744,073,709,551,615).
*/
</code></pre>

<br><br><br>Here is a HalfAdder and a FullAdder in HDL, it returns a sum and a carry.
<pre><code class="language-js">CHIP HalfAdder {
    IN a, b;    // 1-bit inputs
    OUT sum,    // Right bit of a + b
        carry;  // Left bit of a + b

    PARTS:
    // Put you code here:
    And(a=a, b=b, out=carry);
    Xor(a=a, b=b, out=sum);
}

//|   a   |   b   |  sum  | carry |
//|   0   |   0   |   0   |   0   |
//|   0   |   1   |   1   |   0   |
//|   1   |   0   |   1   |   0   |
//|   1   |   1   |   0   |   1   |

CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:

    HalfAdder(a=a,    b=b, sum=sum1, carry=carry1);
    HalfAdder(a=sum1, b=c, sum=sum,  carry=carry2);

    Or(a=carry1, b=carry2, out=carry);
}

//|   a   |   b   |   c   |  sum  | carry |
//|   0   |   0   |   0   |   0   |   0   |
//|   0   |   0   |   1   |   1   |   0   |
//|   0   |   1   |   0   |   1   |   0   |
//|   0   |   1   |   1   |   0   |   1   |
//|   1   |   0   |   0   |   1   |   0   |
//|   1   |   0   |   1   |   0   |   1   |
//|   1   |   1   |   0   |   0   |   1   |
//|   1   |   1   |   1   |   1   |   1   |
</code></pre><br><br>
However negative numbers can be a bit tricky.
<a href='https://en.wikipedia.org/wiki/Two%27s_complement'>2's Complement representation</a>
<pre><code class="language-js">
  //-2 + - 3 is in 2's compliment 14 + 13

  -2      14    1110
  +      +     +
  -3      13    1101
  ___    ___   _____
  -5      11    (1)1011

  11011 = 27  (14+13)
  without the carrying bit: 1011=11 which is 11s the 2's compliment -5!

  Here is a trick to find the 2's complement:
   1111
  -
   1011  //11
  +   1
  ______
   0101 //5

</code></pre><br><br>

We didn't make any chip for multiplication or division, it will be done in
software. This is how binary multiplcation works:
<pre><code class="language-js">
     1011   //(this is 11 in binary)
   x 1110   //(this is 14 in binary)
   ======
     0000   //(this is 1011 x 0)
    1011    //(this is 1011 x 1, shifted one position to the left)
   1011     //(this is 1011 x 1, shifted two positions to the left)
+ 1011      //(this is 1011 x 1, shifted three positions to the left)
=========
10011010   //(this is 154 in binary)
</code></pre><br><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ubCCemtuZH8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<br><br><br>
<h4><i class="fas fa-microchip"></i> Memory</h4><br>
We don't just want to run one calculation but multiple after each other.
We break up the physical time into a time unit 1, 2, 3, 4 with a clock, to run our Sequential Logic. <br>
The physical time between the time unit is enough for the delays of the curcuits to set it to on or off (1,0).
<br><br>
<p><b>Combinatorial:</b> out[t] = function(int[t])</p>
<p><b>Sequential:</b> out[t] = function(in[t-1])</p>

<br>
<ul>
<li>Combinational logic uses only the present inputs to determine the
output while sequential logic uses both present inputs as well as
previous outputs to determine the current input.</li>

<li>Combinational logic is used to implement basic Boolean
  operations while sequential logic is used to create memory elements.</li>

<li>Sequential logic uses the feedbacks from the output
to inputs while combinational logic does not require feedbacks.</li>
</ul>
<br>
<b>Flip Flops</b><br>
This is flip-flop constructed from cross-coupled NOR gates. In the course it was done with two nand gates<br><br>
<img src="https://upload.wikimedia.org/wikipedia/commons/c/c6/R-S_mk2.gif" alt="">
<br><br>The flip-flop kind of "delays" the out value one time unit.
<b>out[t] = in[t-1]</b><br><br>
From a flip Flop we can create a 1-Bit register..
<pre><code class="language-js">if load(t-1) then out(t)=in(t-1)
else out(t)=out(t-1)
</code></pre><br><br>
This can be created with a Multiplexer and a DFF (data flip-flop)

<pre><code class="language-js">CHIP Bit {
    IN  in, load;
    OUT out;

    PARTS:
        Mux(a = loopIn, b = in, sel = load, out = outMux);
        DFF(in = outMux, out = loopIn, out = out);
}
</code></pre><br>
and from this we can now build a PC (program counter) a Register, a Ram8 and a Ram16 etc..<br>
(Part of <a href="https://www.nand2tetris.org/project03">Project03</a>)<br><br>
For the Ram every register have an adress, if load==1, then
the in value is loaded into the memory location specified by address.<br>
<b>The width of the adress</b> for a 8bits register is 3bits. (input = log2n)<br>
Log of 8 in base 2 is 3. So register number 0 will be represented with a
code 000. register number 7 will be represented with a code 111.<br>
And then we have all the possibilities in the middle.
So the length of the address input, which we call k in this diagram equals
log of n, the number of registers in this particular RAM device.<br><br>
In a computer there is also other types of memory, like caches, Rom and we also can have a ssd and a hdd.<br>
While Ram is flushed when the computer is shutdown the Rom keeps it data.
Most of the "Initilize" stuff is stored in the Rom.
<br><br>

Accesing a memory location is expensive. We need to supply a long adress and
getting the memory contents into the CPU takes time. <br>The solution: <b>Memory Heirarchy!</b>
<br><br>
<img src="https://upload.wikimedia.org/wikipedia/commons/0/0c/ComputerMemoryHierarchy.svg" alt="" height=50% width=50%>
<br>
The farther away from the arithmetic unit we get the bigger grows the memory.<br>
Smaller memory means smaller memory adress. CPUs usually contain a few, easily accessed "registers".<br>
Their number and functions are a central part of the machine language.
<br><br>
<h4><i class="fas fa-language"></i> Machine & Assembly Language</h4><br>
An Instruction in binary could be "010001000110010" to add two register togheter,
a more convinent way would be to say ADD R3 to R2:
<pre><code class="language-js">//add Register 3 to register 2
0100010 | 0011 | 0010
ADD        R3     R2
</code></pre><br><br>
<b>Addressing Modes:</b>
<ul>
  <li><b>Register:</b><br>Add R1, R2  //R2 <i class="fas fa-arrow-left"></i>R2+R1</li>
  <li><b>Direct:</b><br>Add R1, M[200]  //Mem[200] <i class="fas fa-arrow-left"></i>Mem[200] + R1</li>
  <li><b>Indirect:</b><br>Add R1, @A  //Mem[A] <i class="fas fa-arrow-left"></i>Mem[A]+R1</li>
  <li><b>Immediate:</b><br>Add 73, R1  //R1 <i class="fas fa-arrow-left"></i>R1+73</li>
</ul>
<br>
So this is about where to take the data from and where to put the data.<br><br>
<b>How is input and output dealt with in Machine Language?</b><br><br>
There are a lot of input devices, keyboards, screens, printers etc.<br>
One way to access these input/outputs devices is to connect the registers
which controls them as part of your memory.<br>
An example could be that when the user moves or clicks the mouse button, that last movment
is stored into a register. The register can then be accessed by the computer by a adress.
This gives us access to the I/O as if it was part of the memory and then the software who deals with this
(usually the drivers in a OS) must know where to access the adresses and how to speak with it.<br><br>
<b>Flow Control</b><br>
Usually the CPU executes machine instructions in sequence.
However sometimes when for e.g running a loop we need to jump to
another location and do a unconditionally jump.<br><br>

<b>Instruction Memory -> CPU <-data in/out-> data memory</b><br>
In the course we built a 16-bit machine. it consists of:
<br>- Data Memory (Ram): a sequence of 16 bit registers<br>
- Instruction Memory (Rom): also a seq of 16bit register<br>
- Central Processing Unit (CPU): performs the 16-bits instructions<br>
- Instruction bus / data bus / adress buses<br><br>

Two ways of express the same semantics:<br>
<pre><code class="language-js">//Symbolic
@17
D+1;JLE

//Binary
0000000000010001
1110011111000110
</code></pre>
If you write it the symbolic way you'll need something to translate it to Binary.
<br><br>
the machine language in the course Im taking recognizes three registers:<br>
D holds a 16bit value<br>
A holds a 16bit value<br>
M represents the 16-bit ram register addressed by A<br>
<br>
<pre><code class="language-js">//Syntax
@value
//where value is either a non-negative decimal constant or
//a symbol referring to such a constant
//Semantix
//Sets the A register to 'value'
//Side Effect: RAM[A] becomes the selected RAM register
//example
@21
// sets the A register to 21
// RAM[21] becomes the selected RAM register

// set Ram[100] to -1
@100 // A = 100  (a for adressing)
M=-1 // RAM[100]=-1
</code></pre>
<br>
<pre><code class="language-js">//The C-instruction
  dest = comp ; jump //both dest and jump are optional
</code></pre>
<br>
<pre><code class="language-js">//comp =
  0, 1, -1, D, A, !D, !A, -D, -A, D+1, A+1
  D-1, A-1, D+A, D-A, D&A, D|A, M, !M, -M, M+1,
  M-1, D+M, M-D, D&M, M-D, D&M, D|M
</code></pre>
<br>
<pre><code class="language-js">//dest =
  null, M, D, MD, A, AM, AD, AMD  //M refers to RAM[A]
</code></pre>
<br>
<pre><code class="language-js">//jump =
  null, JGT, JEQ, JGE, JLT, JNE, JLE, JMP
</code></pre>
<br>

<pre><code class="language-js">// Set the 0 register to -1
D=-1

// set RAM[300] to the value of the D register minus 1
@300 // A = 300
M = D-1

// if (D-1==0) jump to execute the instruction stored in RAM[56]
@56 // A=56 select adress
D-1;JEQ // if D-1 equal 0 jump to  56

</code></pre><br>

<pre><code class="language-js">
  //Symbolic syntax @Value
  @21
  //Binary syntax 0value
  (0)000000000010101
  // the last zero is sometimes called an op-code
  // "operation code"
</code></pre><br>
<pre><code class="language-js">//Symbolic Syntax
dest = comp; jump

//binary syntax
1 1 1 a c1 c2 c3 c4 c5 c6 d1 d2 d3 j1 j2 j3

  (1)    |   1 1    | a c1 c2 c3 c4 c5 c6 |  d1 d2 d3  | j1 j2 j3
//op-code  not used       comp bits          dest bits   jump bits
</code></pre>
A nice table can be found <a href="http://www1.idc.ac.il/tecs/lectures/lecture%20about%20chapter%2004.pdf">Here</a>.
<br><br>
<h4><i class="far fa-keyboard"></i> I/O </h4>


<b>Screen memory map</b><br>
A designated memory area, dedicated to manage a display unit.
The Physical display is continously <i>refreshed</i> from the memory map,
many times per second.<br>
Output is effected by writing code that manipulates the screen memory map.
<br>Display Unit(256 by 512, b/w), pixels that we can turn on and off, that is
driven by a bit. This needs a mapping, which bit correspons to which pixel.
<br>1. word=Screen[32*row + col/16]
<br>   word = RAM[16384 + 32*row + col/16]
<br> 2 set the (col%16)th bit of word 0 or 1
<br>Commit word to the RAM
<br><br>
<i>Example: change the bit in row 4 column 55. which address should you retrieve,
and which bit should you change?</i><br>
word = Screen[32*4 + 55/16] (integer)<br>
word = Screen[128 + 3]<br>
word = Screen[131]<br>
7 = 55%16 (col%16)th bit<br>
<br>
Answer: Screen[131], 7th bit<br>
<br>
<b>Keyboard Memory map</b><br>
To represent the keyboard we don't need more then 16bit.<br>
When a key is pressed on the keyboard the key's "scan code" appears
in the <i>keyboard memory map</i><br>
example: if 'k' is pressed the scan-code of 'k' is 75, which is
going to look like this '0000000001001011' in the keyboard chip.<br>
If the keyboard is not used they keyboard chip is all zero.
<br><br><br><br>
Von Neumann architecture<br>
<img src="https://upload.wikimedia.org/wikipedia/commons/6/68/Computer_system_bus.svg" alt="" height=40% width=40%><br>
<h4><i class="fas fa-recycle"></i> The Fetch-execute cycle</h4>
The basic operation of a computer is called the ‘fetch-execute’ cycle. <br>
The computer fetches the instruction from its memory and then executes it.
This is done repeatedly from when the computer is booted up to when it is shut down.<br><br>
The program counter


<br><br><br>
<i class="fas fa-rocket"></i> <a href="https://github.com/chrislgarry/Apollo-11/blob/master/Comanche055/AGC_BLOCK_TWO_SELF-CHECK.agc">Assambler code form Apollo-II</a><br>
<i class="far fa-grin-squint-tears"></i> <a href="https://www.bbc.com/bitesize/guides/zws8d2p/revision/1">These BBC pages are really nice, simple!</a>
